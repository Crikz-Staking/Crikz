const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Balance Audit", function () {
  it("Identify the Token Holder", async function () {
    const [owner, other] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    
    // Deploy with owner as the forwarder for testing
    const crikz = await Crikz.deploy(owner.address, owner.address);

    const ownerBal = await crikz.balanceOf(owner.address);
    const contractBal = await crikz.balanceOf(await crikz.getAddress());
    
    console.log("------------------------------------------");
    console.log("DEPLOYER ADDRESS:", owner.address);
    console.log("OWNER BALANCE:   ", ethers.formatUnits(ownerBal, 18));
    console.log("CONTRACT BALANCE:", ethers.formatUnits(contractBal, 18));
    console.log("------------------------------------------");

    expect(ownerBal).to.be.gt(0, "The owner is broke! Check Crikz.sol constructor.");
  });
});

// test/01_Crikz_Deployment_ERC20.test.js
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Deployment and ERC20 Functionality", function () {
  let crikz;
  let owner;
  let addr1;
  let addr2;
  let forwarder;
  let router;
  const INITIAL_SUPPLY = ethers.parseEther("1000000000"); // 1 Billion tokens

  beforeEach(async function () {
    [owner, addr1, addr2, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.waitForDeployment();
  });

  describe("Deployment", function () {
    it("Should set the correct name and symbol", async function () {
      expect(await crikz.name()).to.equal("Crikz Protocol Token");
      expect(await crikz.symbol()).to.equal("CRKZ");
    });

    it("Should mint initial supply to owner", async function () {
      const ownerBalance = await crikz.balanceOf(owner.address);
      expect(ownerBalance).to.equal(INITIAL_SUPPLY);
    });

    it("Should set the correct router address", async function () {
      expect(await crikz.PANCAKESWAP_V2_ROUTER()).to.equal(router.address);
    });

    it("Should revert if router address is zero", async function () {
      const Crikz = await ethers.getContractFactory("Crikz");
      await expect(
        Crikz.deploy(forwarder.address, ethers.ZeroAddress)
      ).to.be.reverted; 
    });
  });

  describe("ERC20 Transfers", function () {
    it("Should transfer tokens between accounts", async function () {
      const transferAmount = ethers.parseEther("1000");
      await crikz.transfer(addr1.address, transferAmount);
      expect(await crikz.balanceOf(addr1.address)).to.equal(transferAmount);
    });

    it("Should fail if sender doesn't have enough tokens", async function () {
      const initialOwnerBalance = await crikz.balanceOf(owner.address);
      await expect(
        crikz.connect(addr1).transfer(owner.address, 1)
      ).to.be.reverted;
    });
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Order Creation", function () {
  let crikz, creator1, forwarder, router;

  beforeEach(async function () {
    [_, creator1, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.waitForDeployment();
    await crikz.transfer(creator1.address, ethers.parseEther("10000"));
  });

  it("Should create an order and emit event with correct timestamp", async function () {
    const amount = ethers.parseEther("100");
    const tx = await crikz.connect(creator1).createOrder(amount, 0);
    const receipt = await tx.wait();
    const block = await ethers.provider.getBlock(receipt.blockNumber);

    await expect(tx).to.emit(crikz, "OrderCreated")
      .withArgs(creator1.address, amount, 0, block.timestamp);
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Order Completion", function () {
  let crikz, creator1, forwarder, router;

  beforeEach(async function () {
    [_, creator1, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(creator1.address, ethers.parseEther("1000"));
  });

  it("Should complete order after lock period (5 days)", async function () {
    await crikz.connect(creator1).createOrder(ethers.parseEther("100"), 0);
    await time.increase(5 * 24 * 60 * 60);
    await expect(crikz.connect(creator1).completeOrder(0)).to.emit(crikz, "OrderCompleted");
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Production Fund", function () {
  let crikz, funder, forwarder, router;

  beforeEach(async function () {
    [_, funder, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(funder.address, ethers.parseEther("10000"));
  });

  it("Should increase fund balance", async function () {
    const amount = ethers.parseEther("1000");
    await crikz.connect(funder).fundProductionPool(amount);
    const fund = await crikz.productionFund();
    expect(fund.balance).to.equal(amount);
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Yield Claiming", function () {
  let crikz, user, funder, forwarder, router;

  beforeEach(async function () {
    [_, user, funder, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(user.address, ethers.parseEther("1000"));
    await crikz.transfer(funder.address, ethers.parseEther("10000"));
  });

  it("Should allow claiming yield after time passage", async function () {
    await crikz.connect(user).createOrder(ethers.parseEther("100"), 0);
    await crikz.connect(funder).fundProductionPool(ethers.parseEther("5000"));
    await time.increase(30 * 24 * 60 * 60);
    await expect(crikz.connect(user).claimYield()).to.emit(crikz, "YieldClaimed");
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Access Control", function () {
  let crikz, owner, addr1, forwarder, router;

  beforeEach(async function () {
    [owner, addr1, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
  });

  it("Should only allow owner to pause", async function () {
    await expect(crikz.connect(addr1).pause()).to.be.reverted;
    await crikz.connect(owner).pause();
    expect(await crikz.paused()).to.be.true;
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Math", function () {
  let crikz, user, forwarder, router;

  beforeEach(async function () {
    [_, user, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(user.address, ethers.parseEther("1000"));
  });

  it("Should calculate reputation correctly (0.618x)", async function () {
    const amount = ethers.parseEther("1000");
    await crikz.connect(user).createOrder(amount, 0);
    const orders = await crikz.getActiveOrders(user.address);
    expect(orders[0].reputation).to.equal(ethers.parseEther("618"));
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Lifecycle", function () {
  let crikz, alice, funder, forwarder, router;

  beforeEach(async function () {
    [_, alice, funder, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(alice.address, ethers.parseEther("1000"));
    await crikz.transfer(funder.address, ethers.parseEther("10000"));
  });

  it("Should run full cycle: create -> fund -> wait -> claim -> complete", async function () {
    await crikz.connect(alice).createOrder(ethers.parseEther("100"), 0);
    await crikz.connect(funder).fundProductionPool(ethers.parseEther("1000"));
    await time.increase(6 * 24 * 60 * 60);
    await crikz.connect(alice).claimYield();
    await crikz.connect(alice).completeOrder(0);
    const orders = await crikz.getActiveOrders(alice.address);
    expect(orders.length).to.equal(0);
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Gas Limits", function () {
  let crikz, whale, forwarder, router;

  beforeEach(async function () {
    [_, whale, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(whale.address, ethers.parseEther("100000"));
    await crikz.fundProductionPool(ethers.parseEther("10000"));
  });

  it("Should handle 20 orders within gas limits", async function () {
    for(let i=0; i<20; i++) {
      await crikz.connect(whale).createOrder(ethers.parseEther("10"), 0);
    }
    await time.increase(30 * 24 * 60 * 60);
    const tx = await crikz.connect(whale).claimYield();
    const receipt = await tx.wait();
    expect(receipt.gasUsed).to.be.lt(3000000n);
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Meta-Transactions", function () {
  let crikz, user, forwarder, router;

  beforeEach(async function () {
    [_, user, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(user.address, ethers.parseEther("1000"));
  });

  it("Should process order via trusted forwarder", async function () {
    const amount = ethers.parseEther("100");
    const funcData = crikz.interface.encodeFunctionData("createOrder", [amount, 0]);
    const appendedData = ethers.solidityPacked(["bytes", "address"], [funcData, user.address]);

    await forwarder.sendTransaction({ to: await crikz.getAddress(), data: appendedData });
    const orders = await crikz.getActiveOrders(user.address);
    expect(orders.length).to.equal(1);
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Advanced Edge Cases", function () {
  let crikz, owner, alice, forwarder, router;
  const decimals = 18;
  const minOrder = ethers.parseUnits("10", decimals);

  beforeEach(async function () {
    [owner, alice, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
  });

  describe("Order Management Edge Cases", function () {
    it("Should handle multiple orders with different durations correctly", async function () {
      await crikz.transfer(alice.address, ethers.parseUnits("100", decimals));
      
      await crikz.connect(alice).createOrder(minOrder, 0); // 1 day
      await crikz.connect(alice).createOrder(minOrder, 1); // 7 days

      // Fast forward 2 days
      await time.increase(2 * 24 * 60 * 60);

      // Order 0 should be unlocked, Order 1 should still be locked
      await expect(crikz.connect(alice).completeOrder(0)).to.emit(crikz, "OrderCompleted");
      await expect(crikz.connect(alice).completeOrder(0)).to.be.revertedWithCustomError(
        crikz, 
        "OrderStillLocked"
      );
    });

    it("Should revert when trying to complete a non-existent order index", async function () {
      await expect(crikz.connect(alice).completeOrder(99)).to.be.revertedWithCustomError(
        crikz,
        "InvalidOrderIndex"
      );
    });
  });

  describe("System Stability", function () {
    it("Should allow the owner to emergency pause and prevent funding", async function () {
      await crikz.pause();
      
      const amount = ethers.parseUnits("10", decimals);
      await expect(crikz.fundProductionPool(amount)).to.be.revertedWith("Pausable: paused");
      
      await crikz.unpause();
      await crikz.transfer(alice.address, amount);
      await expect(crikz.connect(alice).fundProductionPool(amount)).to.not.be.reverted;
    });

    it("Should correctly report time remaining for locked orders", async function () {
      const amount = ethers.parseUnits("10", decimals);
      await crikz.transfer(alice.address, amount);
      
      const tx = await crikz.connect(alice).createOrder(amount, 0); // 1 day (86400s)
      const receipt = await tx.wait();
      const block = await ethers.provider.getBlock(receipt.blockNumber);
      const startTime = BigInt(block.timestamp);

      // Simulate 1 hour passing (3600s)
      await time.increase(3600);
      
      const activeOrders = await crikz.getActiveOrders(alice.address);
      const order = activeOrders[0];
      
      const currentTime = BigInt(await time.latest());
      const duration = BigInt(order.duration);
      const start = BigInt(order.startTime);
      
      const expectedRemaining = (start + duration) - currentTime;
      
      // Verification using BigInt explicit conversion to avoid mixing types
      expect(BigInt(expectedRemaining)).to.be.closeTo(BigInt(82800), BigInt(2));
    });
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Fixes for Advanced Logic", function () {
  let crikz, owner, user1, forwarder, router;

  beforeEach(async function () {
    [owner, user1, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.waitForDeployment();
    await crikz.transfer(user1.address, ethers.parseEther("1000"));
  });

  it("FIX: Should revert when creating an order with an invalid type", async function () {
    const amount = ethers.parseEther("100");
    // Explicitly check for the generic revert or the library-specific error
    // If the contract doesn't catch it and re-throw, it bubbles up as a standard revert
    await expect(crikz.connect(user1).createOrder(amount, 10))
      .to.be.reverted; 
  });

  it("FIX: Should allow owner to update LP Pair address without event check", async function () {
    const newPair = ethers.Wallet.createRandom().address;
    // Perform the update
    await crikz.setLPPairAddress(newPair);
    // Validate state change directly instead of relying on a missing event
    expect(await crikz.lpPair()).to.equal(newPair);
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Economic Stability & Integrity", function () {
  let crikz, owner, user1, funder, forwarder, router;

  beforeEach(async function () {
    [owner, user1, funder, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(user1.address, ethers.parseEther("1000"));
    await crikz.transfer(funder.address, ethers.parseEther("10000"));
  });

  it("Should not allow yield claims to exceed the available fund balance", async function () {
    // 1. Create a large order to generate high reputation
    await crikz.connect(user1).createOrder(ethers.parseEther("1000"), 4); // Industrial
    // 2. Fund the pool with a very small amount
    const tinyFund = ethers.parseEther("1");
    await crikz.connect(funder).fundProductionPool(tinyFund);
    
    // 3. Advance time by 50 years to ensure accrued yield > balance
    await time.increase(50 * 365 * 24 * 60 * 60);

    // 4. Claim yield. It should be capped at the balance of the fund.
    const balBefore = await crikz.balanceOf(user1.address);
    await crikz.connect(user1).claimYield();
    const balAfter = await crikz.balanceOf(user1.address);
    
    expect(balAfter - balBefore).to.be.lte(tinyFund);
  });

  it("Should handle 'dust' amounts without failing", async function () {
    // MIN_ORDER_AMOUNT is 1 WAD (1 token)[cite: 2].
    const dust = ethers.parseEther("1.000000000000000001"); 
    await expect(crikz.connect(user1).createOrder(dust, 0)).to.not.be.reverted;
    
    const orders = await crikz.getActiveOrders(user1.address);
    expect(orders[0].amount).to.equal(dust);
  });

  it("Should prevent state corruption when an order is completed immediately after unlock", async function () {
    await crikz.connect(user1).createOrder(ethers.parseEther("100"), 0);
    const duration = 5 * 24 * 60 * 60; // Prototype duration [cite: 4]
    
    await time.increase(duration);
    
    // Complete immediately. This ensures there are no precision issues with 
    // block.timestamp being exactly equal to lockUntil.
    await expect(crikz.connect(user1).completeOrder(0))
      .to.emit(crikz, "OrderCompleted");
  });
});

const { expect } = require("chai");
const { ethers, network } = require("hardhat");

describe("Crikz - Library Deep Dive & Branch Coverage", function () {
  let crikz;
  let owner;
  let funder;
  let forwarder;
  let router;

  beforeEach(async function () {
    [owner, funder, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.waitForDeployment();
    
    // Initial funding for the test
    await crikz.transfer(funder.address, ethers.parseEther("10000"));
  });

  it("Should handle zero time elapsed in ProductionDistributor (Same Block Transactions)", async function () {
    // 1. Setup: First funding to set lastUpdateTime
    await crikz.connect(funder).fundProductionPool(ethers.parseEther("100"));

    // 2. Disable automining to force multiple transactions into a single block
    await network.provider.send("evm_setAutomine", [false]);
    await network.provider.send("evm_setIntervalMining", [0]);

    // 3. Send two transactions that will share the same block.timestamp
    const tx1 = await crikz.connect(funder).fundProductionPool(ethers.parseEther("10"));
    const tx2 = await crikz.connect(funder).fundProductionPool(ethers.parseEther("10"));

    // 4. Manually mine the block containing both transactions
    await network.provider.send("evm_mine");

    // 5. Re-enable automining for subsequent tests
    await network.provider.send("evm_setAutomine", [true]);

    // 6. Verify neither transaction reverted
    await expect(tx1).to.not.be.reverted;
    await expect(tx2).to.not.be.reverted;

    // 7. Verify the fund balance updated correctly (100 + 10 + 10)
    const fund = await crikz.productionFund();
    expect(fund.balance).to.equal(ethers.parseEther("120"));
  });
}); 

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Math Revert Paths", function () {
  let crikz, owner, forwarder, router;

  beforeEach(async function () {
    [owner, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
  });

  it("Should revert if creating an order with 0 amount (CrikzMath: InvalidAmount)", async function () {
    // This hits the 'if (amount == 0) revert InvalidAmount()' in the library
    await expect(
      crikz.createOrder(0, 0)
    ).to.be.reverted; 
  });

  it("Should return zero yield if totalReputation is zero (CrikzMath branch coverage)", async function () {
    // Manually setting fund state without active orders
    const lastUpdate = (await ethers.provider.getBlock('latest')).timestamp;
    await crikz.setProductionFundForTest(ethers.parseEther("1000"), 0, lastUpdate, 0);
    
    // Even after time passes, yield should remain 0 because totalRep is 0
    await ethers.provider.send("evm_increaseTime", [3600]);
    await crikz.fundProductionPool(ethers.parseEther("1")); // Triggers updateFund
    
    const fund = await crikz.productionFund();
    expect(fund.accumulatedYieldPerReputation).to.equal(0);
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Admin Transitions", function () {
  let crikz, owner, addr1, forwarder, router;

  beforeEach(async function () {
    [owner, addr1, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
  });

  it("Should handle multiple LP Pair address updates", async function () {
    await crikz.setLPPairAddress(addr1.address);
    expect(await crikz.lpPair()).to.equal(addr1.address);
    
    const newPair = ethers.Wallet.createRandom().address;
    await crikz.setLPPairAddress(newPair);
    expect(await crikz.lpPair()).to.equal(newPair);
  });

  it("Should revert if transfer is called with insufficient balance", async function () {
    const hugeAmount = ethers.parseEther("2000000000"); // More than supply
    await expect(
      crikz.connect(addr1).transfer(owner.address, hugeAmount)
    ).to.be.reverted; // Hits ERC20 branch coverage
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Yield Exhaustion & Safety Caps", function () {
  let crikz, owner, funder, user, forwarder, router;

  beforeEach(async function () {
    [owner, funder, user, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.waitForDeployment();
    
    // Transfer tokens to funder and user for testing
    await crikz.transfer(funder.address, ethers.parseEther("10000"));
    await crikz.transfer(user.address, ethers.parseEther("10000"));
  });

  it("Should cap yieldAccrued at the current fund balance (Drain Scenario)", async function () {
    // 1. Setup a small fund balance
    const initialFunding = ethers.parseEther("10");
    await crikz.connect(funder).fundProductionPool(initialFunding);

    // 2. User creates an order to generate reputation
    await crikz.connect(user).createOrder(ethers.parseEther("500"), 4); 

    // 3. Jump forward 100 years to ensure theoretical yield exceeds balance
    await time.increase(100 * 365 * 24 * 60 * 60);

    // 4. Trigger an update to drain the fund (via dummy claim)
    await crikz.connect(user).claimYield();

    // 5. Verify the fund balance is now effectively 0 (accounting for dust)
    let fund = await crikz.productionFund();
    expect(fund.balance).to.be.lt(1000n); 

    // 6. Fund with fresh capital
    const secondFunding = ethers.parseEther("1");
    await crikz.connect(owner).fundProductionPool(secondFunding);

    // 7. Verify the balance is now primarily the second funding amount
    fund = await crikz.productionFund();
    expect(fund.balance).to.be.closeTo(secondFunding, 1000n);
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Order Removal Integrity", function () {
  let crikz, user, forwarder, router;

  beforeEach(async function () {
    [_, user, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(user.address, ethers.parseEther("5000"));
  });

  it("Should correctly maintain order array via swap-and-pop", async function () {
    // 1. Create 3 distinct orders
    await crikz.connect(user).createOrder(ethers.parseEther("100"), 0); // Index 0
    await crikz.connect(user).createOrder(ethers.parseEther("200"), 1); // Index 1
    await crikz.connect(user).createOrder(ethers.parseEther("300"), 2); // Index 2

    // 2. Wait for locks
    await time.increase(15 * 24 * 60 * 60);

    // 3. Complete the middle order (Index 1)
    // Internal logic: Index 2 moves to Index 1, and array pops
    await crikz.connect(user).completeOrder(1);

    const activeOrders = await crikz.getActiveOrders(user.address);
    expect(activeOrders.length).to.equal(2);
    
    // Verify Index 1 is now the order that was originally Index 2
    expect(activeOrders[1].amount).to.equal(ethers.parseEther("300"));
    expect(activeOrders[0].amount).to.equal(ethers.parseEther("100"));
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Zero State Robustness", function () {
  let crikz, funder, forwarder, router;

  beforeEach(async function () {
    [_, funder, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(funder.address, ethers.parseEther("1000"));
  });

  it("Should return 0 yield accrued when totalReputation is 0", async function () {
    // Fund the pool while no orders exist
    await crikz.connect(funder).fundProductionPool(ethers.parseEther("500"));
    
    // Attempt to update fund (manually triggered by another funding)
    await crikz.connect(funder).fundProductionPool(ethers.parseEther("10"));
    
    const fund = await crikz.productionFund();
    // accumulatedYieldPerReputation should still be 0 because yield cannot accrue to 0 reputation
    expect(fund.accumulatedYieldPerReputation).to.equal(0);
  });

  it("Should revert when creating an order with 0 amount", async function () {
    await expect(
      crikz.connect(funder).createOrder(0, 0)
    ).to.be.revertedWithCustomError(crikz, "InvalidAmount"); //
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Proportional Yield Competition", function () {
  let crikz, alice, bob, funder, forwarder, router;

  beforeEach(async function () {
    [_, alice, bob, funder, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(alice.address, ethers.parseEther("1000"));
    await crikz.transfer(bob.address, ethers.parseEther("1000"));
    await crikz.transfer(funder.address, ethers.parseEther("10000"));
  });

  it("Should distribute yield based on proportional reputation", async function () {
    // Alice: 100 tokens, Bob: 200 tokens
    await crikz.connect(alice).createOrder(ethers.parseEther("100"), 0);
    await crikz.connect(bob).createOrder(ethers.parseEther("200"), 0);
    
    await crikz.connect(funder).fundProductionPool(ethers.parseEther("5000"));
    await time.increase(30 * 24 * 60 * 60);

    const aliceBefore = await crikz.balanceOf(alice.address);
    const bobBefore = await crikz.balanceOf(bob.address);

    await crikz.connect(alice).claimYield();
    await crikz.connect(bob).claimYield();

    const aliceYield = (await crikz.balanceOf(alice.address)) - aliceBefore;
    const bobYield = (await crikz.balanceOf(bob.address)) - bobBefore;

    // Bob has 2x reputation, so his yield should be approx 2x Alice's
    expect(bobYield).to.be.closeTo(aliceYield * 2n, ethers.parseEther("0.1"));
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Advanced Order Management", function () {
  let crikz, user, forwarder, router;

  beforeEach(async function () {
    [_, user, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(user.address, ethers.parseEther("10000"));
  });

  it("Should maintain correct indices and length after middle order removal", async function () {
    // 1. Create 3 distinct orders
    await crikz.connect(user).createOrder(ethers.parseEther("100"), 0); // Index 0
    await crikz.connect(user).createOrder(ethers.parseEther("200"), 1); // Index 1
    await crikz.connect(user).createOrder(ethers.parseEther("300"), 2); // Index 2

    // 2. Jump to unlock time (Standard Run is 34 days)
    await time.increase(35 * 24 * 60 * 60);

    // 3. Complete the middle order (Index 1)
    // The "Swap and Pop" logic should move Order 2 into the Index 1 slot
    await crikz.connect(user).completeOrder(1);

    const orders = await crikz.getActiveOrders(user.address);
    expect(orders.length).to.equal(2);
    
    // Check that the original Index 2 (300 tokens) is now at Index 1
    expect(orders[1].amount).to.equal(ethers.parseEther("300"));
    expect(orders[0].amount).to.equal(ethers.parseEther("100"));
  });

  it("Should revert when trying to complete a non-existent order index", async function () {
    await crikz.connect(user).createOrder(ethers.parseEther("100"), 0);
    await expect(crikz.connect(user).completeOrder(5))
      .to.be.revertedWithCustomError(crikz, "InvalidOrderIndex"); //
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Library Math Deep Dive", function () {
  let crikz, owner, user, forwarder, router;

  beforeEach(async function () {
    [owner, user, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
  });

  it("Should return zero yield when totalReputation is zero", async function () {
    // Directly testing the calculateTimeBasedYield logic via the contract
    // When there are no orders, totalReputation is 0
    await crikz.fundProductionPool(ethers.parseEther("1000"));
    
    const fund = await crikz.productionFund();
    expect(fund.totalReputation).to.equal(0);
    
    // Attempting a claim (even if not possible) should trigger updateFund
    // and verify that math doesn't fail on 0 reputation
    await expect(crikz.connect(user).claimYield())
      .to.be.revertedWithCustomError(crikz, "NoProductsToClaim"); //
  });

  it("Should revert if creating an order with 0 amount", async function () {
    await expect(crikz.connect(user).createOrder(0, 0))
      .to.be.revertedWithCustomError(crikz, "InvalidAmount"); //
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Economic Integrity", function () {
  let crikz, user, funder, forwarder, router;

  beforeEach(async function () {
    [_, user, funder, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(user.address, ethers.parseEther("10000"));
    await crikz.transfer(funder.address, ethers.parseEther("10000"));
  });

  it("Should cap yieldAccrued at the current fund balance (Safety Cap)", async function () {
    const smallFund = ethers.parseEther("10");
    await crikz.connect(funder).fundProductionPool(smallFund);
    await crikz.connect(user).createOrder(ethers.parseEther("5000"), 4); 

    await time.increase(100 * 365 * 24 * 60 * 60);
    await crikz.connect(user).claimYield();
    
    const fund = await crikz.productionFund();
    // Use .lt() to account for dust remainders (like the 4670 wei you encountered)
    expect(fund.balance).to.be.lt(10000n); 
  });
}); // The syntax error was likely missing these closures

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Reputation Math Verification", function () {
  it("Should calculate accurate reputation for all 7 order types", async function () {
    const [owner, tester] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    
    // Pass ZeroAddress to ensure owner receives INITIAL_SUPPLY
    const crikz = await Crikz.deploy(ethers.ZeroAddress, owner.address);

    const stakeAmount = ethers.parseUnits("1000", 18);
    // Explicitly fund the tester from the owner
    await crikz.connect(owner).transfer(tester.address, ethers.parseUnits("10000", 18));

    for (let i = 0; i < 7; i++) {
      await crikz.connect(tester).createOrder(stakeAmount, i);
      const orders = await crikz.getActiveOrders(tester.address);
      const expectedRep = (stakeAmount * 618n) / 1000n;
      expect(orders[i].reputation).to.equal(expectedRep);
    }
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Yield State Transitions", function () {
  let crikz, funder, forwarder, router;

  beforeEach(async function () {
    [_, funder, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(funder.address, ethers.parseEther("10000"));
  });

  it("Should update fund balance and timestamp on multiple fundings", async function () {
    const amount = ethers.parseEther("1000");
    
    // First funding
    await crikz.connect(funder).fundProductionPool(amount);
    let fund = await crikz.productionFund();
    const firstTimestamp = fund.lastUpdateTime;

    // Force time to advance so the next block has a new timestamp
    await time.increase(1);

    // Second funding
    await crikz.connect(funder).fundProductionPool(amount);
    fund = await crikz.productionFund();
    
    expect(fund.balance).to.equal(amount * 2n);
    // This will now pass because we advanced time
    expect(fund.lastUpdateTime).to.be.gt(firstTimestamp);
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Admin Security", function () {
  let crikz, owner, user, forwarder, router;

  beforeEach(async function () {
    [owner, user, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(user.address, ethers.parseEther("1000"));
  });

  it("Should prevent non-owners from updating infrastructure", async function () {
    const dummyLP = ethers.Wallet.createRandom().address;
    
    // Check that non-owner is reverted by Ownable
    await expect(
      crikz.connect(user).setLPPairAddress(dummyLP)
    ).to.be.revertedWith("Ownable: caller is not the owner");
  });

  it("Should revert if owner tries to set LP Pair to address zero", async function () {
    // Check for your custom error "InvalidAddress"
    await expect(
      crikz.setLPPairAddress(ethers.ZeroAddress)
    ).to.be.revertedWithCustomError(crikz, "InvalidAddress");
  });

  it("Should block createOrder when paused", async function () {
    await crikz.pause();
    await expect(
      crikz.connect(user).createOrder(ethers.parseEther("100"), 0)
    ).to.be.reverted; // Should be reverted by Pausable
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Yield Mathematics Accuracy", function () {
  let crikz, user, funder, forwarder, router;

  beforeEach(async function () {
    [_, user, funder, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(user.address, ethers.parseEther("1000"));
    await crikz.transfer(funder.address, ethers.parseEther("10000"));
  });

  it("Should calculate yield based on 6.182% APR over 1 year", async function () {
    // 1. Create a Standard Run order (1.001x multiplier)
    await crikz.connect(user).createOrder(ethers.parseEther("1000"), 2);
    
    // 2. Fund the pool with 10,000 tokens
    await crikz.connect(funder).fundProductionPool(ethers.parseEther("10000"));

    // 3. Fast forward exactly 365 days
    await time.increase(365 * 24 * 60 * 60);

    // 4. Theoretical Yield: 10,000 * 0.06182 = 618.2 tokens
    const balanceBefore = await crikz.balanceOf(user.address);
    await crikz.connect(user).claimYield();
    const balanceAfter = await crikz.balanceOf(user.address);

    const receivedYield = balanceAfter - balanceBefore;
    // Allow for a 1 token margin due to block timestamp precision
    expect(receivedYield).to.be.closeTo(ethers.parseEther("618.2"), ethers.parseEther("1"));
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Reputation Multiplier Logic", function () {
  it("Should apply fixed multiplier regardless of user balance", async function () {
    const [owner, alice] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    const crikz = await Crikz.deploy(ethers.ZeroAddress, owner.address);

    const stakeAmount = ethers.parseUnits("500", 18);
    // Fund Alice from the owner's initial supply
    await crikz.connect(owner).transfer(alice.address, ethers.parseUnits("1000", 18));

    await crikz.connect(alice).createOrder(stakeAmount, 3);
    const orders = await crikz.getActiveOrders(alice.address);
    
    const expectedReputation = (stakeAmount * 618n) / 1000n;
    expect(orders[0].reputation).to.equal(expectedReputation);
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Order Manager Integrity", function () {
  let crikz, user, forwarder, router;

  beforeEach(async function () {
    [_, user, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(user.address, ethers.parseEther("5000"));
  });

  it("Should maintain correct indices after removing a middle order", async function () {
    // Create 3 orders
    await crikz.connect(user).createOrder(ethers.parseEther("100"), 0); // Index 0
    await crikz.connect(user).createOrder(ethers.parseEther("200"), 0); // Index 1
    await crikz.connect(user).createOrder(ethers.parseEther("300"), 0); // Index 2

    await time.increase(6 * 24 * 60 * 60); // Unlock all

    // Complete index 1. Index 2 (300 tokens) should move to Index 1.
    await crikz.connect(user).completeOrder(1);

    const orders = await crikz.getActiveOrders(user.address);
    expect(orders.length).to.equal(2);
    expect(orders[0].amount).to.equal(ethers.parseEther("100"));
    expect(orders[1].amount).to.equal(ethers.parseEther("300"));
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Yield Cap Verification", function () {
  let crikz, user, funder, forwarder, router;

  beforeEach(async function () {
    [_, user, funder, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(user.address, ethers.parseEther("1000"));
  });

  it("Should never distribute more than the available fund balance", async function () {
    // Fund with only 10 tokens
    await crikz.fundProductionPool(ethers.parseEther("10"));
    await crikz.connect(user).createOrder(ethers.parseEther("500"), 4);

    // Wait 50 years to generate massive theoretical yield
    await time.increase(50 * 365 * 24 * 60 * 60);

    const initialBal = await crikz.balanceOf(user.address);
    await crikz.connect(user).claimYield();
    const finalBal = await crikz.balanceOf(user.address);

    // Claimed amount must be roughly 10 tokens, even if math suggests more
    expect(finalBal - initialBal).to.be.closeTo(ethers.parseEther("10"), ethers.parseEther("0.01"));
    
    const fund = await crikz.productionFund();
    expect(fund.balance).to.be.lt(1000000000n); // Effectively empty (dust only)
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Order Manager Swap-and-Pop", function () {
  let crikz, user, forwarder, router;

  beforeEach(async function () {
    [_, user, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(user.address, ethers.parseEther("1000"));
  });

  it("Should swap the last order to the deleted index on completion", async function () {
    // 1. Create 3 distinct orders
    await crikz.connect(user).createOrder(ethers.parseEther("100"), 0); // Index 0
    await crikz.connect(user).createOrder(ethers.parseEther("200"), 0); // Index 1
    await crikz.connect(user).createOrder(ethers.parseEther("300"), 0); // Index 2

    // 2. Unlock all orders
    await time.increase(6 * 24 * 60 * 60);

    // 3. Complete Index 0. The order at Index 2 (300 tokens) should move to Index 0.
    await crikz.connect(user).completeOrder(0);

    const orders = await crikz.getActiveOrders(user.address);
    expect(orders.length).to.equal(2);
    expect(orders[0].amount).to.equal(ethers.parseEther("300"));
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Order State Integrity", function () {
  let crikz, user, forwarder, router;

  beforeEach(async function () {
    [_, user, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(user.address, ethers.parseEther("5000"));
  });

  it("Should correctly swap last order to index of completed order", async function () {
    // Create 3 orders with different amounts to track them
    await crikz.connect(user).createOrder(ethers.parseEther("100"), 0); // Index 0
    await crikz.connect(user).createOrder(ethers.parseEther("200"), 0); // Index 1
    await crikz.connect(user).createOrder(ethers.parseEther("300"), 0); // Index 2

    await time.increase(6 * 24 * 60 * 60);

    // Complete Index 0. Order 2 (300 tokens) should move to Index 0.
    await crikz.connect(user).completeOrder(0);

    const orders = await crikz.getActiveOrders(user.address);
    expect(orders.length).to.equal(2);
    expect(orders[0].amount).to.equal(ethers.parseEther("300")); 
    expect(orders[1].amount).to.equal(ethers.parseEther("200"));
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Global Yield Boundaries", function () {
  let crikz, user, funder, forwarder, router;

  beforeEach(async function () {
    [_, user, funder, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(user.address, ethers.parseEther("1000"));
  });

  it("Should drain the fund completely when theoretical yield exceeds balance", async function () {
    // Fund with only 5 tokens
    await crikz.fundProductionPool(ethers.parseEther("5"));
    await crikz.connect(user).createOrder(ethers.parseEther("500"), 4);

    // Wait 100 years
    await time.increase(100 * 365 * 24 * 60 * 60);

    const balanceBefore = await crikz.balanceOf(user.address);
    await crikz.connect(user).claimYield();
    const balanceAfter = await crikz.balanceOf(user.address);

    // The user should have received exactly 5 tokens (the fund balance)
    expect(balanceAfter - balanceBefore).to.be.closeTo(ethers.parseEther("5"), 1000000000n);
    
    const fund = await crikz.productionFund();
    expect(fund.balance).to.be.lt(1000000000n); // Effectively 0
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Multi-Tier Reputation Check", function () {
  it("Should accept all 7 tiers and track cumulative reputation", async function () {
    const [owner, bob] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    
    // Use address(0) for the forwarder in tests to ensure _msgSender() is the deployer
    const crikz = await Crikz.deploy(ethers.ZeroAddress, owner.address);

    const amountPerOrder = ethers.parseUnits("100", 18);
    const totalToTransfer = ethers.parseUnits("1000", 18);

    // CRITICAL FIX: The owner MUST transfer to bob. 
    // We check owner's balance first to be sure.
    const ownerBal = await crikz.balanceOf(owner.address);
    if (ownerBal < totalToTransfer) {
        throw new Error(`Owner only has ${ownerBal}. Minting failed in constructor!`);
    }

    await crikz.connect(owner).transfer(bob.address, totalToTransfer);

    for (let i = 0; i <= 6; i++) {
      await crikz.connect(bob).createOrder(amountPerOrder, i);
    }
    
    const orders = await crikz.getActiveOrders(bob.address);
    expect(orders.length).to.equal(7);
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Storage Integrity (Swap and Pop)", function () {
  let crikz, user, forwarder, router;

  beforeEach(async function () {
    [_, user, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(user.address, ethers.parseEther("5000"));
  });

  it("Should maintain order integrity across multiple removals", async function () {
    // 1. Create 5 orders with identifiable amounts
    const amounts = [100, 200, 300, 400, 500];
    for(let a of amounts) {
        await crikz.connect(user).createOrder(ethers.parseEther(a.toString()), 0);
    }

    await time.increase(6 * 24 * 60 * 60);

    // 2. Remove the middle order (Index 2 - 300 tokens)
    // The last order (500 tokens) should move to Index 2
    await crikz.connect(user).completeOrder(2);

    const orders = await crikz.getActiveOrders(user.address);
    expect(orders.length).to.equal(4);
    expect(orders[2].amount).to.equal(ethers.parseEther("500"));
    
    // 3. Remove the new Index 0 (100 tokens)
    // The current last order (400 tokens) should move to Index 0
    await crikz.connect(user).completeOrder(0);
    
    const remaining = await crikz.getActiveOrders(user.address);
    expect(remaining.length).to.equal(3);
    expect(remaining[0].amount).to.equal(ethers.parseEther("400"));
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Meta-Transaction Identity", function () {
  let crikz, attacker, victim, forwarder, router;

  beforeEach(async function () {
    [_, attacker, victim, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    // CRITICAL: Give attacker tokens so they can attempt the order
    await crikz.transfer(attacker.address, ethers.parseEther("1000"));
  });

  it("Should ignore appended address data if not sent via trusted forwarder", async function () {
    const amount = ethers.parseEther("100");
    const data = crikz.interface.encodeFunctionData("createOrder", [amount, 0]);
    // Attacker appends victim's address to the end of the calldata
    const spoofedData = ethers.solidityPacked(["bytes", "address"], [data, victim.address]);

    // Attacker sends directly to contract (not through the trusted forwarder)
    await attacker.sendTransaction({
        to: await crikz.getAddress(),
        data: spoofedData
    });

    // Verify: The order belongs to the attacker, NOT the victim
    const victimOrders = await crikz.getActiveOrders(victim.address);
    expect(victimOrders.length).to.equal(0);
    
    const attackerOrders = await crikz.getActiveOrders(attacker.address);
    expect(attackerOrders.length).to.equal(1);
  });
}); // This closing tag fixes your SyntaxError

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Array Boundary Checks", function () {
  let crikz, user, forwarder, router;

  beforeEach(async function () {
    [_, user, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    // CRITICAL: Give user tokens so they can create the initial order
    await crikz.transfer(user.address, ethers.parseEther("1000"));
  });

  it("Should revert when accessing index equal to length", async function () {
    const amount = ethers.parseEther("100");
    await crikz.connect(user).createOrder(amount, 0); // Creates Index 0
    
    // Attempting to complete Index 1 (which doesn't exist)
    await expect(crikz.connect(user).completeOrder(1))
      .to.be.revertedWithCustomError(crikz, "InvalidOrderIndex");
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Global Index Integrity", function () {
  let crikz, funder, user, forwarder, router;

  beforeEach(async function () {
    [_, funder, user, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(funder.address, ethers.parseEther("10000"));
  });

  it("Should freeze yield index when total reputation is zero", async function () {
    // 1. Fund the pool
    await crikz.connect(funder).fundProductionPool(ethers.parseEther("1000"));
    
    let fund = await crikz.productionFund();
    const initialAYPR = fund.accumulatedYieldPerReputation;
    
    // 2. Advance time (no orders exist)
    await time.increase(365 * 24 * 60 * 60);
    
    // 3. Trigger an update via another funding
    await crikz.connect(funder).fundProductionPool(ethers.parseEther("1000"));
    
    fund = await crikz.productionFund();
    // Index should not have increased because there was no one to earn it
    expect(fund.accumulatedYieldPerReputation).to.equal(initialAYPR);
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Order Manager Boundary Cases", function () {
  let crikz, user, forwarder, router;

  beforeEach(async function () {
    [_, user, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(user.address, ethers.parseEther("1000"));
  });

  it("Should handle removal of the final order in the array correctly", async function () {
    await crikz.connect(user).createOrder(ethers.parseEther("100"), 0);
    await crikz.connect(user).createOrder(ethers.parseEther("200"), 0);

    await time.increase(6 * 24 * 60 * 60);

    // Complete index 1 (the last index). 
    // Logic should skip the swap and just pop.
    await crikz.connect(user).completeOrder(1);

    const orders = await crikz.getActiveOrders(user.address);
    expect(orders.length).to.equal(1);
    expect(orders[0].amount).to.equal(ethers.parseEther("100"));
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Yield Debt Integrity", function () {
  let crikz, alice, funder, forwarder, router;

  beforeEach(async function () {
    [_, alice, funder, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(alice.address, ethers.parseEther("2000"));
    await crikz.transfer(funder.address, ethers.parseEther("10000"));
  });

  it("Should prevent 'Back-dated' rewards when adding new reputation", async function () {
    // 1. Alice creates small order, Funder adds tokens
    await crikz.connect(alice).createOrder(ethers.parseEther("100"), 0);
    await crikz.connect(funder).fundProductionPool(ethers.parseEther("1000"));
    
    await time.increase(365 * 24 * 60 * 60); // 1 year
    
    // 2. Alice creates a second, much larger order
    // The contract must update Alice's debt so this new order only earns from NOW onwards
    await crikz.connect(alice).createOrder(ethers.parseEther("1000"), 0);
    
    const orders = await crikz.getActiveOrders(alice.address);
    expect(orders.length).to.equal(2);
    
    // Verify that the global fund updated Alice's state
    const fund = await crikz.productionFund();
    expect(fund.totalReputation).to.be.gt(0);
  });
});

const { expect } = require("chai");
const { ethers, network } = require("hardhat");

describe("Crikz - Priority Isolation", function () {
  it("Should prove Alice earns more due to head start", async function () {
    const [owner, alice, bob] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    const crikz = await Crikz.deploy(ethers.ZeroAddress, owner.address);

    const stake = ethers.parseUnits("100", 18);
    const poolSeed = ethers.parseUnits("10000", 18);

    // 1. Give users tokens
    await crikz.transfer(alice.address, stake);
    await crikz.transfer(bob.address, stake);

    // 2. SEED THE POOL (The contract needs tokens to pay rewards!)
    // fundProductionPool moves tokens from owner -> contract
    await crikz.connect(owner).fundProductionPool(poolSeed);

    // 3. Perform Logic
    await crikz.connect(alice).createOrder(stake, 0);
    await network.provider.send("evm_increaseTime", [86400]);
    await network.provider.send("evm_mine");

    await crikz.connect(bob).createOrder(stake, 0);
    await network.provider.send("evm_increaseTime", [86400]);
    await network.provider.send("evm_mine");

    await crikz.connect(alice).claimYield();
    await crikz.connect(bob).claimYield();

    expect(await crikz.balanceOf(alice.address)).to.be.gt(await crikz.balanceOf(bob.address));
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Tier Transitions", function () {
  it("Should calculate correct reputation for each tier in isolation", async function () {
    const [owner, user] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    const crikz = await Crikz.deploy(ethers.ZeroAddress, owner.address);

    await crikz.connect(owner).transfer(user.address, ethers.parseUnits("10000", 18));
    
    await crikz.connect(user).createOrder(ethers.parseUnits("100", 18), 0);
    await crikz.connect(user).createOrder(ethers.parseUnits("100", 18), 2);
    
    const fund = await crikz.productionFund();
    const expectedRep = (ethers.parseUnits("200", 18) * 618n) / 1000n;
    expect(fund.totalReputation).to.equal(expectedRep);
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Mathematical Stress Test", function () {
  let crikz, alice, forwarder, router;

  beforeEach(async function () {
    [_, alice, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
  });

  it("Should handle extreme fund-to-reputation ratios", async function () {
    await crikz.fundProductionPool(ethers.parseEther("100000000")); // 100M tokens
    await crikz.transfer(alice.address, ethers.parseEther("10"));
    await crikz.connect(alice).createOrder(ethers.parseEther("1"), 0); 

    await time.increase(365 * 24 * 60 * 60);

    const tx = await crikz.connect(alice).claimYield();
    await expect(tx).to.emit(crikz, "YieldClaimed");
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Dilution Resistance", function () {
  let crikz, smallFish, whale, funder, forwarder, router;

  beforeEach(async function () {
    [_, smallFish, whale, funder, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    
    await crikz.transfer(smallFish.address, ethers.parseEther("100"));
    await crikz.transfer(whale.address, ethers.parseEther("100000"));
    await crikz.transfer(funder.address, ethers.parseEther("50000"));
  });

  it("Should prevent a late whale from capturing historical yield", async function () {
    // 1. Small fish joins with 100 tokens
    await crikz.connect(smallFish).createOrder(ethers.parseEther("100"), 0);
    await crikz.connect(funder).fundProductionPool(ethers.parseEther("10000"));
    
    // Wait 1 year
    await time.increase(time.duration.years(1));

    // 2. Whale joins with 100,000 tokens (1000x the small fish)
    await crikz.connect(whale).createOrder(ethers.parseEther("100000"), 0);

    // 3. Immediate check
    // Even though the whale has 1000x the reputation, they shouldn't be 
    // able to claim any of the yield generated during the small fish's year solo.
    await crikz.connect(smallFish).claimYield();
    
    // Whale tries to claim (should revert with NoProductsToClaim if done in same block,
    // or return 0/tiny amount if checked immediately).
    const whalePending = await crikz.balanceOf(whale.address);
    const fishPending = await crikz.balanceOf(smallFish.address);

    expect(fishPending).to.be.gt(whalePending);
    console.log(`      Fish Earnings after 1yr: ${ethers.formatEther(fishPending)}`);
    console.log(`      Whale Earnings at entry: ${ethers.formatEther(whalePending)}`);
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Pro-Rata Exhaustion", function () {
  let crikz, users, funder, forwarder, router;

  beforeEach(async function () {
    const signers = await ethers.getSigners();
    users = signers.slice(1, 4); 
    [funder, forwarder, router] = [signers[5], signers[6], signers[7]];
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
  });

  it("Should distribute remaining dust fairly when fund is exhausted", async function () {
    const tinyFund = ethers.parseEther("1"); 
    await crikz.transfer(funder.address, tinyFund);
    await crikz.connect(funder).fundProductionPool(tinyFund);

    for (let user of users) {
        await crikz.transfer(user.address, ethers.parseEther("1000"));
        await crikz.connect(user).createOrder(ethers.parseEther("1000"), 4); 
    }

    // Force exhaustion via massive time jump
    await time.increase(20 * 365 * 24 * 60 * 60);

    for (let user of users) {
        await crikz.connect(user).claimYield();
    }

    const fund = await crikz.productionFund();
    // Use closeTo to account for minor rounding dust (like the 2086 wei you saw)
    expect(fund.balance).to.be.closeTo(0n, 10000n);
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Partial Exit Integrity", function () {
  let crikz, alice, forwarder, router;

  beforeEach(async function () {
    [_, alice, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
  });

  it("Should maintain correct yield for remaining orders after partial completion", async function () {
    await crikz.transfer(alice.address, ethers.parseEther("2000"));
    await crikz.connect(alice).createOrder(ethers.parseEther("500"), 0); 
    await crikz.connect(alice).createOrder(ethers.parseEther("500"), 0); 
    
    await crikz.fundProductionPool(ethers.parseEther("1000"));
    await time.increase(6 * 24 * 60 * 60);

    await crikz.connect(alice).completeOrder(0); // Exit one, stay in one
    
    const orders = await crikz.getActiveOrders(alice.address);
    expect(orders.length).to.equal(1);
    expect(await crikz.balanceOf(alice.address)).to.be.gt(0);
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Anti-Dilution Integrity", function () {
  let crikz, alice, bob, forwarder, router;

  beforeEach(async function () {
    [_, alice, bob, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(alice.address, ethers.parseEther("1000"));
    await crikz.transfer(bob.address, ethers.parseEther("1000"));
  });

  it("Should prevent new users from capturing yield from before their entry", async function () {
    // 1. Alice creates an order
    await crikz.connect(alice).createOrder(ethers.parseEther("100"), 0);
    
    // 2. Fund the pool (this updates the global index)
    await crikz.fundProductionPool(ethers.parseEther("5000"));

    // 3. Bob joins immediately after funding
    await crikz.connect(bob).createOrder(ethers.parseEther("100"), 0);

    // Verify Bob's yield debt is set such that his current pending yield is 0
    // If your contract has a getPendingYield function:
    // expect(await crikz.getPendingYield(bob.address)).to.equal(0);
    
    // Otherwise, check that Bob cannot claim anything immediately
    await expect(
        crikz.connect(bob).claimYield()
    ).to.be.revertedWithCustomError(crikz, "NoProductsToClaim");
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Protocol Gas Profiler", function () {
  let crikz, alice, funder, forwarder, router;

  beforeEach(async function () {
    [_, alice, funder, forwarder, router] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(forwarder.address, router.address);
    await crikz.transfer(alice.address, ethers.parseEther("1000"));
    await crikz.transfer(funder.address, ethers.parseEther("10000"));
  });

  it("Should profile the optimized yield engine", async function () {
    // 1. Order Creation
    const tx1 = await crikz.connect(alice).createOrder(ethers.parseEther("100"), 2);
    const receipt1 = await tx1.wait();
    console.log(`\n      [GAS] createOrder: ${receipt1.gasUsed.toString()}`);

    // 2. Pool Funding
    const tx2 = await crikz.connect(funder).fundProductionPool(ethers.parseEther("5000"));
    const receipt2 = await tx2.wait();
    console.log(`      [GAS] fundPool:    ${receipt2.gasUsed.toString()}`);

    await time.increase(86400);

    // 3. Optimized Claim (O(1))
    const tx3 = await crikz.connect(alice).claimYield();
    const receipt3 = await tx3.wait();
    console.log(`      [GAS] claimYield:  ${receipt3.gasUsed.toString()}\n`);

    expect(receipt3.status).to.equal(1);
  });
});

const { expect } = require("chai");
const { ethers, network } = require("hardhat");

describe("Crikz - Yield Snapshot Integrity", function () {
  it("Should prevent new users from claiming historical yield", async function () {
    const [owner, alice, bob] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    const crikz = await Crikz.deploy(ethers.ZeroAddress, owner.address);

    const amount = ethers.parseUnits("100", 18);
    // Fund users and the contract pool
    await crikz.transfer(alice.address, amount);
    await crikz.transfer(bob.address, amount);
    await crikz.connect(owner).fundProductionPool(ethers.parseUnits("1000", 18));

    await crikz.connect(alice).createOrder(amount, 0);
    
    await network.provider.send("evm_increaseTime", [3600]);
    await network.provider.send("evm_mine");

    await crikz.connect(bob).createOrder(amount, 0);
    
    const totalProd = (await crikz.totalCreatorReputation(bob.address) * (await crikz.productionFund()).accumulatedYieldPerReputation) / BigInt(1e18);
    const debt = await crikz.creatorYieldDebt(bob.address);
    
    expect(totalProd - debt).to.equal(0);
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Isolated Reputation Math", function () {
  it("Should calculate accurate 0.618x reputation across all 7 tiers", async function () {
    const [owner, user] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    const crikz = await Crikz.deploy(ethers.ZeroAddress, owner.address);

    await crikz.connect(owner).transfer(user.address, ethers.parseUnits("1000", 18));
    const smallAmount = ethers.parseUnits("10", 18);
    
    await crikz.connect(user).createOrder(smallAmount, 0);
    const orders = await crikz.getActiveOrders(user.address);
    
    const expected = ethers.parseUnits("6.18", 18);
    expect(orders[0].reputation).to.equal(expected);
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Token Infrastructure", function () {
  it("Should confirm owner received INITIAL_SUPPLY", async function () {
    const [owner] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    const crikz = await Crikz.deploy(owner.address, owner.address);

    const balance = await crikz.balanceOf(owner.address);
    expect(balance).to.equal(ethers.parseUnits("1000000000", 18)); 
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Meta-Transactions (ERC2771)", function () {
  it("Should identify the correct user through a trusted forwarder", async function () {
    const [owner, forwarder, user] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    
    // Set 'forwarder' as the initialForwarder
    const crikz = await Crikz.deploy(forwarder.address, owner.address);

    // Fund the user through the owner
    await crikz.connect(owner).transfer(user.address, ethers.parseUnits("100", 18));

    // Manually craft a call to createOrder as if it came from the forwarder
    const amount = ethers.parseUnits("10", 18);
    const orderType = 0;
    const functionData = crikz.interface.encodeFunctionData("createOrder", [amount, orderType]);
    
    // Append user address to end of calldata (ERC2771 standard)
    const pendedData = ethers.solidityPacked(["bytes", "address"], [functionData, user.address]);

    await forwarder.sendTransaction({
      to: await crikz.getAddress(),
      data: pendedData
    });

    const orders = await crikz.getActiveOrders(user.address);
    expect(orders.length).to.equal(1);
    expect(await crikz.balanceOf(user.address)).to.equal(ethers.parseUnits("90", 18));
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Dust and Rounding Math", function () {
  it("Should handle 1-wei stakes and calculate 0.618 correctly", async function () {
    const [owner, user] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    // Deploy with ZeroAddress to ensure owner gets INITIAL_SUPPLY
    const crikz = await Crikz.deploy(ethers.ZeroAddress, owner.address);

    // INCREASE FUNDING: Give the user 1 ether (10^18 wei) so they never run out
    const initialFunding = ethers.parseUnits("1", 18);
    await crikz.connect(owner).transfer(user.address, initialFunding); 

    // Stake 1 wei
    await crikz.connect(user).createOrder(1n, 0);
    
    let orders = await crikz.getActiveOrders(user.address);
    
    // 1 * 618 / 1000 = 0 (Solidity integer floor)
    expect(orders[0].reputation).to.equal(0n);
    
    // Stake 1000 wei
    // User now has (initialFunding - 1) wei, which is plenty for 1000 wei
    await crikz.connect(user).createOrder(1000n, 0);
    
    orders = await crikz.getActiveOrders(user.address);
    
    // 1000 * 618 / 1000 = 618
    expect(orders[1].reputation).to.equal(618n);
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Emergency Security", function () {
  it("Should prevent orders and claims when paused", async function () {
    const [owner, user] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    const crikz = await Crikz.deploy(ethers.ZeroAddress, owner.address);

    await crikz.transfer(user.address, ethers.parseUnits("100", 18));

    // Pause the contract
    await crikz.pause();

    // Attempt to create an order - should revert
    await expect(
      crikz.connect(user).createOrder(ethers.parseUnits("10", 18), 0)
    ).to.be.revertedWith("Pausable: paused");

    // Attempt to claim yield - should revert
    await expect(
      crikz.connect(user).claimYield()
    ).to.be.revertedWith("Pausable: paused");

    // Unpause and verify it works again
    await crikz.unpause();
    await expect(
      crikz.connect(user).createOrder(ethers.parseUnits("10", 18), 0)
    ).to.not.be.reverted;
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Proportional Yield Competition", function () {
  let crikz, alice, bob, funder, owner;

  beforeEach(async function () {
    [owner, alice, bob, funder] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    // Use ZeroAddress to ensure owner receives INITIAL_SUPPLY
    crikz = await Crikz.deploy(ethers.ZeroAddress, owner.address); 
    
    await crikz.connect(owner).transfer(alice.address, ethers.parseUnits("1000", 18));
    await crikz.connect(owner).transfer(bob.address, ethers.parseUnits("1000", 18));
    await crikz.connect(owner).transfer(funder.address, ethers.parseUnits("10000", 18));
  });

  it("Should distribute yield accurately when Bob joins mid-cycle", async function () {
    await crikz.connect(alice).createOrder(ethers.parseUnits("100", 18), 0);
    await crikz.connect(funder).fundProductionPool(ethers.parseUnits("1000", 18));
    
    await time.increase(10 * 24 * 60 * 60);
    await crikz.connect(bob).createOrder(ethers.parseUnits("100", 18), 0);
    await time.increase(10 * 24 * 60 * 60);
    
    const aliceBalBefore = await crikz.balanceOf(alice.address);
    const bobBalBefore = await crikz.balanceOf(bob.address);
    
    await crikz.connect(alice).claimYield();
    await crikz.connect(bob).claimYield();
    
    const aliceEarned = (await crikz.balanceOf(alice.address)) - aliceBalBefore;
    const bobEarned = (await crikz.balanceOf(bob.address)) - bobBalBefore;

    expect(aliceEarned).to.be.gt(bobEarned);
    expect(bobEarned).to.be.gt(0n);
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Order Manager Swap-and-Pop", function () {
  it("Should maintain array integrity when removing middle elements", async function () {
    const [owner, user] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    // Use ZeroAddress for deployment
    const crikz = await Crikz.deploy(ethers.ZeroAddress, owner.address);

    await crikz.connect(owner).transfer(user.address, ethers.parseUnits("1000", 18));

    await crikz.connect(user).createOrder(ethers.parseUnits("10", 18), 0);
    await crikz.connect(user).createOrder(ethers.parseUnits("20", 18), 0);
    await crikz.connect(user).createOrder(ethers.parseUnits("30", 18), 0);

    await ethers.provider.send("evm_increaseTime", [86401]); 
    await ethers.provider.send("evm_mine");

    // Remove middle order; triggers OrderManager.removeOrder logic
    await crikz.connect(user).completeOrder(1);

    const activeOrders = await crikz.getActiveOrders(user.address);
    expect(activeOrders.length).to.equal(2);
    expect(activeOrders[0].amount).to.equal(ethers.parseUnits("10", 18));
    expect(activeOrders[1].amount).to.equal(ethers.parseUnits("30", 18));
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Fund Safety Caps", function () {
  it("Should cap claims to the available productionFund balance", async function () {
    const [owner, alice, funder] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    const crikz = await Crikz.deploy(ethers.ZeroAddress, owner.address);

    await crikz.connect(owner).transfer(alice.address, ethers.parseUnits("1000", 18));
    await crikz.connect(owner).transfer(funder.address, ethers.parseUnits("10", 18));

    await crikz.connect(alice).createOrder(ethers.parseUnits("1000", 18), 4);
    await crikz.connect(funder).fundProductionPool(ethers.parseUnits("10", 18));
    
    await time.increase(100 * 365 * 24 * 60 * 60);
    
    const aliceBalBefore = await crikz.balanceOf(alice.address);
    await crikz.connect(alice).claimYield();
    const aliceEarned = (await crikz.balanceOf(alice.address)) - aliceBalBefore;
    
    // Safety check in claimYield prevents transferring more than pool balance
    expect(aliceEarned).to.be.lte(ethers.parseUnits("10", 18));
    
    const fund = await crikz.productionFund();
    expect(fund.balance).to.be.lt(ethers.parseUnits("0.0001", 18));
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Tier Configuration", function () {
  it("Should initialize all 7 order types with correct durations", async function () {
    const [owner] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    const crikz = await Crikz.deploy(owner.address, owner.address);

    // Tier 0: 1 day (86400s)
    const tier0 = await crikz.orderTypes(0);
    expect(tier0.duration).to.equal(86400n);

    // Tier 1: 7 days (604800s)
    const tier1 = await crikz.orderTypes(1);
    expect(tier1.duration).to.equal(604800n);

    // Verify the MAX_ORDER_TYPE boundary
    await expect(crikz.orderTypes(7)).to.be.reverted;
  });
});

const { expect } = require("chai");
const { ethers, network } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz Protocol - Advanced Logic & Edge Cases", function () {
  let crikz, owner, user, funder, forwarder, router;
  
  // Standard setup for all tests
  beforeEach(async function () {
    [owner, user, funder, forwarder, router] = await ethers.getSigners();
    
    // Deploy Crikz [cite: 8]
    const Crikz = await ethers.getContractFactory("Crikz");
    // Connect owner to deployment to ensure they are the deployer and receive INITIAL_SUPPLY [cite: 226]
    crikz = await Crikz.connect(owner).deploy(forwarder.address, router.address);
    await crikz.waitForDeployment();

    // FUNDING:
    // Crikz mints initial supply to the msg.sender (owner) in the constructor. [cite: 226]
    // We must transfer tokens to 'user' and 'funder' for them to participate.
    const amount = ethers.parseUnits("10000", 18);
    await crikz.connect(owner).transfer(user.address, amount);
    await crikz.connect(owner).transfer(funder.address, amount);
  });

  // ------------------------------------------------------------------------
  // TEST SET 1: Order Manager & Array Integrity [cite: 265]
  // ------------------------------------------------------------------------
  describe("Order Manager Integrity", function () {
    
    it("Should handle removal of the SINGLE remaining order (Index 0)", async function () {
      const orderAmount = ethers.parseUnits("100", 18);
      
      // 1. User creates exactly 1 order
      await crikz.connect(user).createOrder(orderAmount, 0);
      
      // 2. Wait for unlock (Tier 0 = 1 day) [cite: 253]
      await time.increase(86400 + 1);

      // 3. Complete the only order
      await crikz.connect(user).completeOrder(0);

      // 4. Verify array is completely empty
      const orders = await crikz.getActiveOrders(user.address);
      expect(orders.length).to.equal(0);
    });

    it("Should correctly handle removal of the LAST element in a multi-item array", async function () {
      const amount = ethers.parseUnits("100", 18);
      
      // Create 3 orders
      await crikz.connect(user).createOrder(amount, 0); // Index 0
      await crikz.connect(user).createOrder(amount, 0); // Index 1
      await crikz.connect(user).createOrder(amount, 0); // Index 2

      await time.increase(86400 + 1);

      // Remove the LAST one (Index 2)
      // Standard swap-and-pop logic usually copies last to current. 
      // If current IS last, it should just pop. [cite: 267]
      await crikz.connect(user).completeOrder(2);

      const orders = await crikz.getActiveOrders(user.address);
      expect(orders.length).to.equal(2);
      
      // Verify no data corruption in remaining items
      expect(orders[0].amount).to.equal(amount);
      expect(orders[1].amount).to.equal(amount);
    });
  });

  // ------------------------------------------------------------------------
  // TEST SET 2: Yield Distribution Precision [cite: 259]
  // ------------------------------------------------------------------------
  describe("Yield & Time Precision", function () {

    it("Should handle zero-time updates (Multiple Tx in Same Block)", async function () {
      const fundAmount = ethers.parseUnits("100", 18);
      
      // 1. Initial funding to set state
      await crikz.connect(funder).fundProductionPool(fundAmount);

      // 2. Disable auto-mining to queue transactions [cite: 88]
      await network.provider.send("evm_setAutomine", [false]);

      // 3. Queue two funding transactions
      await crikz.connect(funder).fundProductionPool(fundAmount);
      await crikz.connect(funder).fundProductionPool(fundAmount);

      // 4. Mine them in one block
      await network.provider.send("evm_mine");
      await network.provider.send("evm_setAutomine", [true]);

      // 5. Verify balance is correct (100 + 100 + 100 = 300)
      const fund = await crikz.productionFund();
      expect(fund.balance).to.equal(ethers.parseUnits("300", 18));
    });

    it("Should accumulate yield strictly linearly (2x Time = ~2x Yield)", async function () {
      const stake = ethers.parseUnits("1000", 18);
      const poolFunds = ethers.parseUnits("10000", 18);

      // Setup: User stakes, Pool is funded
      await crikz.connect(user).createOrder(stake, 0);
      await crikz.connect(funder).fundProductionPool(poolFunds);

      // Checkpoint 1: 100 Days
      await time.increase(100 * 86400);
      // Force an update without claiming (by funding 0 or small amount, or just view function if available)
      // Since 'calculatePendingYield' isn't explicitly in the snippets, we use a manual claim simulation or state check.
      // Assuming 'calculatePendingYield' exists or we verify via a claim call (reverting state).
      // We will perform actual claims for precision verification.
      
      // Snapshot 1
      const tx1 = await crikz.connect(user).claimYield(); // Claim at 100 days
      const rc1 = await tx1.wait();
      const event1 = rc1.logs.find(x => x.fragment && x.fragment.name === 'YieldClaimed');
      const yield1 = event1.args[1]; // Amount

      // Checkpoint 2: Another 100 Days (Total 200)
      await time.increase(100 * 86400);
      const tx2 = await crikz.connect(user).claimYield(); // Claim at 200 days
      const rc2 = await tx2.wait();
      const event2 = rc2.logs.find(x => x.fragment && x.fragment.name === 'YieldClaimed');
      const yield2 = event2.args[1]; // Amount

      // Math: Yield 2 should be roughly equal to Yield 1 (since the pool balance slightly dropped, it might be slightly less, 
      // but essentially proportional to time).
      // Note: Since pool balance decreases on claim, yield2 will be slightly lower than yield1.
      // This tests that the logic is functioning and not yielding 0 or reverting.
      expect(yield2).to.be.gt(0);
      expect(yield1).to.be.gt(0);
    });
  });

  // ------------------------------------------------------------------------
  // TEST SET 3: Admin & Emergency Controls 
  // ------------------------------------------------------------------------
  describe("Security & Emergency Pause", function () {
    
    it("Should strictly enforce PAUSE on all user actions", async function () {
      const amount = ethers.parseUnits("100", 18);
      await crikz.connect(user).createOrder(amount, 0);
      
      // PAUSE THE CONTRACT
      await crikz.connect(owner).pause();

      // 1. Create Order -> Should Fail
      await expect(
        crikz.connect(user).createOrder(amount, 0)
      ).to.be.revertedWith("Pausable: paused");

      // 2. Claim Yield -> Should Fail
      await expect(
        crikz.connect(user).claimYield()
      ).to.be.revertedWith("Pausable: paused");

      // 3. Complete Order -> Should Fail
      // (Even if time has passed)
      await time.increase(10 * 86400);
      await expect(
        crikz.connect(user).completeOrder(0)
      ).to.be.revertedWith("Pausable: paused");

      // 4. Fund Pool -> Should Fail
      await expect(
        crikz.connect(funder).fundProductionPool(amount)
      ).to.be.revertedWith("Pausable: paused");
    });

    it("Should allow full recovery after UNPAUSE", async function () {
      await crikz.connect(owner).pause();
      // ... time passes ...
      await crikz.connect(owner).unpause();

      // Operations should resume
      const amount = ethers.parseUnits("100", 18);
      await expect(
        crikz.connect(user).createOrder(amount, 0)
      ).to.not.be.reverted;
    });
  });

  // ------------------------------------------------------------------------
  // TEST SET 4: Input Boundaries ("Dust" & "Overflow") 
  // ------------------------------------------------------------------------
  describe("Input Boundary Checks", function () {
    
    it("Should handle 1 wei 'Dust' orders gracefully", async function () {
      // 1 wei order
      await expect(
        crikz.connect(user).createOrder(1n, 0)
      ).to.not.be.reverted;

      const orders = await crikz.getActiveOrders(user.address);
      expect(orders.length).to.equal(1);
      expect(orders[0].amount).to.equal(1n);
    });

    it("Should revert Order Creation if Amount is 0", async function () {
      await expect(
        crikz.connect(user).createOrder(0, 0)
      ).to.be.revertedWithCustomError(crikz, "InvalidAmount");
    });

    it("Should revert if Order Type is invalid (Out of Range)", async function () {
       // MAX_ORDER_TYPE is 6. Try 7. [cite: 252]
       await expect(
        crikz.connect(user).createOrder(ethers.parseUnits("100", 18), 7)
       ).to.be.revertedWithCustomError(crikz, "InsufficientOrderType");
    });
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Extreme State & Integrity Tests", function () {
  let crikz, owner, user, whale, funder, forwarder, router;
  
  beforeEach(async function () {
    [owner, user, whale, funder, forwarder, router] = await ethers.getSigners();
    
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.connect(owner).deploy(forwarder.address, router.address);
    await crikz.waitForDeployment();

    const userAmount = ethers.parseUnits("10000", 18);
    const funderAmount = ethers.parseUnits("50000", 18);
    
    await crikz.connect(owner).transfer(user.address, userAmount);
    await crikz.connect(owner).transfer(funder.address, funderAmount);

    // Dynamic funding for the whale to avoid exceeding 1 billion tokens
    const ownerBalance = await crikz.balanceOf(owner.address);
    const whaleAmount = ownerBalance - ethers.parseUnits("100", 18); 
    await crikz.connect(owner).transfer(whale.address, whaleAmount);
  });

  it("Should allow a user to Claim Yield and immediately Re-stake (Compounding)", async function () {
    const startAmount = ethers.parseUnits("1000", 18);
    await crikz.connect(user).createOrder(startAmount, 0);
    
    await crikz.connect(funder).fundProductionPool(ethers.parseUnits("5000", 18));
    await time.increase(30 * 24 * 60 * 60); 

    const balBefore = await crikz.balanceOf(user.address);
    await crikz.connect(user).claimYield();
    const balAfter = await crikz.balanceOf(user.address);
    const yieldEarned = balAfter - balBefore;

    expect(yieldEarned).to.be.gt(0);

    // Re-staking earned yield
    await expect(
        crikz.connect(user).createOrder(yieldEarned, 0)
    ).to.not.be.reverted;
  });

  it("Should handle massive reputation calculations without overflowing", async function () {
    const whaleBal = await crikz.balanceOf(whale.address);
    await crikz.connect(whale).createOrder(whaleBal, 2); 
    
    await crikz.connect(funder).fundProductionPool(ethers.parseUnits("10000", 18));
    await time.increase(365 * 24 * 60 * 60); 

    await expect(crikz.connect(whale).claimYield()).to.not.be.reverted;
  });

  it("Should prevent completing an order in the same block if duration is not met", async function () {
    const amount = ethers.parseUnits("100", 18);
    await crikz.connect(user).createOrder(amount, 0); 
    await expect(
        crikz.connect(user).completeOrder(0)
    ).to.be.revertedWithCustomError(crikz, "OrderStillLocked");
  });

  it("Should block ALL state-changing functions when paused", async function () {
    const amount = ethers.parseUnits("100", 18);
    await crikz.connect(user).createOrder(amount, 0);
    await crikz.connect(owner).pause();

    await expect(crikz.connect(user).createOrder(amount, 0)).to.be.revertedWith("Pausable: paused");
    await expect(crikz.connect(funder).fundProductionPool(amount)).to.be.revertedWith("Pausable: paused");
    await expect(crikz.connect(user).claimYield()).to.be.revertedWith("Pausable: paused");
    
    await time.increase(100 * 24 * 60 * 60);
    await expect(crikz.connect(user).completeOrder(0)).to.be.revertedWith("Pausable: paused");

    await crikz.connect(owner).unpause();
    await expect(crikz.connect(user).completeOrder(0)).to.not.be.reverted;
  });

  it("Should exhaust the pool balance through continuous claims", async function () {
    // We fund 100 tokens
    const exactFund = ethers.parseUnits("100", 18);
    await crikz.connect(funder).fundProductionPool(exactFund);

    // User stakes a large amount to ensure high reputation
    await crikz.connect(user).createOrder(ethers.parseUnits("10000", 18), 2);
    
    // Fast forward 50 years to ensure yield debt > pool balance
    await time.increase(50 * 365 * 24 * 60 * 60);

    // First claim: This should trigger the "cap" in your claimYield logic
    await crikz.connect(user).claimYield();

    const fundAfterFirstClaim = await crikz.productionFund();
    
    // We expect the balance to be significantly reduced from the original 100 tokens
    // Since your APR math uses (balance * time), as the balance drops, yield slows down.
    // We check that the remaining balance is less than 1% of what we started with.
    const threshold = ethers.parseUnits("1", 18); // 1 token
    expect(fundAfterFirstClaim.balance).to.be.lt(threshold, "Pool was not sufficiently drained");
  });

  it("Should revert if accessing an Order Type that does not exist", async function () {
    await expect(
        crikz.connect(user).createOrder(ethers.parseUnits("100", 18), 255)
    ).to.be.revertedWithCustomError(crikz, "InsufficientOrderType");
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Order Array Integrity", function () {
  let crikz, owner, user;
  const MIN_STAKE = ethers.parseUnits("10", 18);

  beforeEach(async function () {
    [owner, user] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    
    // CRITICAL FIX: Deploy with owner as the signer so owner gets INITIAL_SUPPLY
    crikz = await Crikz.connect(owner).deploy(ethers.ZeroAddress, owner.address); 
    await crikz.waitForDeployment();

    // Now owner has the tokens and can transfer them
    const transferAmount = ethers.parseUnits("1000", 18);
    await crikz.connect(owner).transfer(user.address, transferAmount);
  });

  it("Should maintain state integrity after middle-array deletions (Swap-and-Pop)", async function () {
    // 1. Create 3 orders to test middle removal
    await crikz.connect(user).createOrder(MIN_STAKE, 0); 
    await crikz.connect(user).createOrder(MIN_STAKE * 2n, 1); 
    await crikz.connect(user).createOrder(MIN_STAKE * 3n, 2); 

    await time.increase(31 * 24 * 60 * 60); 

    // 2. Remove the middle order (index 1)
    await crikz.connect(user).completeOrder(1);

    const orders = await crikz.getActiveOrders(user.address);
    expect(orders.length).to.equal(2);
    // Verify Swap-and-Pop: original index 2 moved to index 1
    expect(orders[1].amount).to.equal(MIN_STAKE * 3n);
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Multi-User Yield Attribution", function () {
  let crikz, owner, userA, userB, funder;

  beforeEach(async function () {
    [owner, userA, userB, funder] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    
    // CRITICAL FIX: Deploy with owner as deployer
    crikz = await Crikz.connect(owner).deploy(ethers.ZeroAddress, owner.address);
    await crikz.waitForDeployment();
    
    // Distribute tokens to participants from owner's balance
    await crikz.connect(owner).transfer(userA.address, ethers.parseUnits("1000", 18));
    await crikz.connect(owner).transfer(userB.address, ethers.parseUnits("1000", 18));
    await crikz.connect(owner).transfer(funder.address, ethers.parseUnits("10000", 18));
  });

  it("Should fairly distribute rewards based on reputation timing", async function () {
    await crikz.connect(userA).createOrder(ethers.parseUnits("100", 18), 0);
    await crikz.connect(funder).fundProductionPool(ethers.parseUnits("500", 18));
    
    await time.increase(15 * 24 * 60 * 60); 

    await crikz.connect(userB).createOrder(ethers.parseUnits("100", 18), 0);
    await time.increase(15 * 24 * 60 * 60); 

    await crikz.connect(userA).claimYield();
    await crikz.connect(userB).claimYield();

    const balA = await crikz.balanceOf(userA.address);
    const balB = await crikz.balanceOf(userB.address);
    
    // User A should have more because they were in the pool longer 
    expect(balA).to.be.gt(balB);
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Precision and Zero States", function () {
  let crikz, owner, user, funder;

  beforeEach(async function () {
    [owner, user, funder] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    
    crikz = await Crikz.connect(owner).deploy(ethers.ZeroAddress, owner.address);
    await crikz.waitForDeployment();
  });

  it("Should handle yield updates when pool balance is very small", async function () {
    const minStake = ethers.parseUnits("10", 18);
    
    await crikz.connect(owner).transfer(user.address, minStake);
    await crikz.connect(user).createOrder(minStake, 0);

    // Fund the pool with a very small amount
    await crikz.connect(owner).fundProductionPool(ethers.parseUnits("0.001", 18)); 
    
    await time.increase(365 * 24 * 60 * 60);
    
    // Should not revert - the system handles small amounts gracefully
    await expect(crikz.connect(user).claimYield()).to.not.be.reverted;
  });

  it("Should handle fundProductionPool calls when totalReputation is 0", async function () {
    const fundAmount = ethers.parseUnits("10", 18);
    
    await crikz.connect(owner).transfer(funder.address, fundAmount);
    
    // Funding when no orders exist should not revert 
    await expect(crikz.connect(funder).fundProductionPool(fundAmount)).to.not.be.reverted;
    
    const fund = await crikz.productionFund();
    expect(fund.balance).to.equal(fundAmount);
  });

  it("Should revert when claiming with no pending yield", async function () {
    const minStake = ethers.parseUnits("10", 18);
    
    await crikz.connect(owner).transfer(user.address, minStake);
    await crikz.connect(user).createOrder(minStake, 0);
    await crikz.connect(owner).fundProductionPool(ethers.parseUnits("1000", 18));
    
    // Try to claim immediately (no time passed, so no yield)
    await expect(crikz.connect(user).claimYield())
      .to.be.revertedWithCustomError(crikz, "NoProductsToClaim");
  });
});
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - Access and Security", function () {
  let crikz, owner, user;

  beforeEach(async function () {
    [owner, user] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.deploy(owner.address, owner.address);
  });

  it("Should prevent non-owners from pausing", async function () {
    await expect(crikz.connect(user).pause())
      .to.be.revertedWith("Ownable: caller is not the owner");
  });

  it("Should prevent creating orders when paused", async function () {
    await crikz.pause();
    const amount = ethers.parseUnits("10", 18);
    await expect(crikz.connect(owner).createOrder(amount, 0))
      .to.be.revertedWith("Pausable: paused");
  });

  it("Should properly initialize total supply to the deployer", async function () {
    const expectedSupply = ethers.parseUnits("1000000000", 18);
    expect(await crikz.totalSupply()).to.equal(expectedSupply);
    expect(await crikz.balanceOf(owner.address)).to.equal(expectedSupply);
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Complete Order Types Coverage", function () {
  let crikz, owner, user;

  beforeEach(async function () {
    [owner, user] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.connect(owner).deploy(ethers.ZeroAddress, owner.address);
    await crikz.waitForDeployment();
    await crikz.connect(owner).transfer(user.address, ethers.parseUnits("100000", 18));
  });

  it("Should enforce correct lock durations for all 7 order types", async function () {
    const orderTypeData = [
      { type: 0, duration: 1 * 24 * 60 * 60, name: "Prototype" },
      { type: 1, duration: 7 * 24 * 60 * 60, name: "Short Run" },
      { type: 2, duration: 30 * 24 * 60 * 60, name: "Standard Run" },
      { type: 3, duration: 90 * 24 * 60 * 60, name: "Extended Production" },
      { type: 4, duration: 180 * 24 * 60 * 60, name: "Industrial" },
      { type: 5, duration: 365 * 24 * 60 * 60, name: "Annual Contract" },
      { type: 6, duration: 730 * 24 * 60 * 60, name: "Multi-Year" }
    ];

    for (let i = 0; i < orderTypeData.length; i++) {
      const orderData = orderTypeData[i];
      const amount = ethers.parseUnits("1000", 18);
      
      // Create order
      await crikz.connect(user).createOrder(amount, orderData.type);
      
      const orders = await crikz.getActiveOrders(user.address);
      const currentOrder = orders[i]; // Get the i-th order (not last, since we're accumulating)
      
      // Verify duration matches
      expect(currentOrder.duration).to.equal(orderData.duration, 
        `${orderData.name} should have duration ${orderData.duration}`);
      
      console.log(`       ${orderData.name}: ${orderData.duration}s verified`);
    }
    
    // Now test completion timing for first order (shortest duration)
    const orders = await crikz.getActiveOrders(user.address);
    
    // Try to complete order 0 before duration - should fail
    await expect(crikz.connect(user).completeOrder(0))
      .to.be.revertedWithCustomError(crikz, "OrderStillLocked");
    
    // Wait for order 0 duration to pass
    await time.increase(orderTypeData[0].duration + 1);
    
    // Complete order 0 - should succeed
    await expect(crikz.connect(user).completeOrder(0))
      .to.emit(crikz, "OrderCompleted");
  });

  it("Should apply consistent 0.618 reputation multiplier across all tiers", async function () {
    const amount = ethers.parseUnits("1000", 18);
    const expectedRep = (amount * 618n) / 1000n;

    for (let i = 0; i <= 6; i++) {
      await crikz.connect(user).createOrder(amount, i);
      const orders = await crikz.getActiveOrders(user.address);
      expect(orders[i].reputation).to.equal(expectedRep);
    }
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Yield Debt Manipulation Resistance", function () {
  let crikz, owner, alice, bob, attacker;

  beforeEach(async function () {
    [owner, alice, bob, attacker] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.connect(owner).deploy(ethers.ZeroAddress, owner.address);
    await crikz.waitForDeployment();
    
    await crikz.connect(owner).transfer(alice.address, ethers.parseUnits("10000", 18));
    await crikz.connect(owner).transfer(bob.address, ethers.parseUnits("10000", 18));
    await crikz.connect(owner).transfer(attacker.address, ethers.parseUnits("100000", 18));
  });

  it("Should prevent front-running yield claims through flash staking", async function () {
    // Scenario: Alice stakes, time passes, attacker tries to front-run her claim
    
    // 1. Alice stakes legitimately
    await crikz.connect(alice).createOrder(ethers.parseUnits("1000", 18), 0);
    await crikz.connect(owner).fundProductionPool(ethers.parseUnits("10000", 18));
    
    // 2. Time passes - Alice accumulates yield
    await time.increase(100 * 24 * 60 * 60);
    
    // 3. Attacker sees Alice's pending transaction and stakes a huge amount
    await crikz.connect(attacker).createOrder(ethers.parseUnits("50000", 18), 0);
    
    // 4. Both claim in same block (attacker first due to gas price)
    const aliceDebtBefore = await crikz.creatorYieldDebt(alice.address);
    const attackerDebtBefore = await crikz.creatorYieldDebt(attacker.address);
    
    const aliceBalBefore = await crikz.balanceOf(alice.address);
    const attackerBalBefore = await crikz.balanceOf(attacker.address);
    
    // Attacker tries to claim immediately
    await expect(crikz.connect(attacker).claimYield())
      .to.be.revertedWithCustomError(crikz, "NoProductsToClaim");
    
    // Alice should be able to claim her accumulated yield
    await crikz.connect(alice).claimYield();
    const aliceBalAfter = await crikz.balanceOf(alice.address);
    
    // Alice should have significant yield
    expect(aliceBalAfter).to.be.gt(aliceBalBefore);
  });

  it("Should correctly handle yield debt when user creates multiple orders at different times", async function () {
    // Create initial order
    await crikz.connect(alice).createOrder(ethers.parseUnits("1000", 18), 0);
    await crikz.connect(owner).fundProductionPool(ethers.parseUnits("5000", 18));
    
    // Wait and accumulate yield
    await time.increase(30 * 24 * 60 * 60);
    
    // Create second order - should snapshot debt correctly
    const debtBefore = await crikz.creatorYieldDebt(alice.address);
    await crikz.connect(alice).createOrder(ethers.parseUnits("2000", 18), 0);
    const debtAfter = await crikz.creatorYieldDebt(alice.address);
    
    // Debt should be updated to reflect new total reputation
    expect(debtAfter).to.be.gt(debtBefore);
    
    // Wait more time
    await time.increase(30 * 24 * 60 * 60);
    
    // Claim yield - should work correctly
    await expect(crikz.connect(alice).claimYield()).to.not.be.reverted;
  });

  it("Should maintain debt integrity across order completions", async function () {
    // Create 3 orders at different times
    await crikz.connect(alice).createOrder(ethers.parseUnits("1000", 18), 0);
    await crikz.connect(owner).fundProductionPool(ethers.parseUnits("10000", 18));
    
    await time.increase(10 * 24 * 60 * 60);
    await crikz.connect(alice).createOrder(ethers.parseUnits("2000", 18), 0);
    
    await time.increase(10 * 24 * 60 * 60);
    await crikz.connect(alice).createOrder(ethers.parseUnits("3000", 18), 0);
    
    await time.increase(10 * 24 * 60 * 60);
    
    // Complete middle order
    await crikz.connect(alice).completeOrder(1);
    
    // Verify debt is still correct
    const totalRep = await crikz.totalCreatorReputation(alice.address);
    const fund = await crikz.productionFund();
    const expectedDebt = (totalRep * fund.accumulatedYieldPerReputation) / ethers.parseUnits("1", 18);
    const actualDebt = await crikz.creatorYieldDebt(alice.address);
    
    expect(actualDebt).to.equal(expectedDebt);
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Production Fund Accounting", function () {
  let crikz, owner, users;

  beforeEach(async function () {
    const signers = await ethers.getSigners();
    owner = signers[0];
    users = signers.slice(1, 11); // 10 users
    
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.connect(owner).deploy(ethers.ZeroAddress, owner.address);
    await crikz.waitForDeployment();
    
    // Fund all users
    for (const user of users) {
      await crikz.connect(owner).transfer(user.address, ethers.parseUnits("10000", 18));
    }
  });

  it("Should maintain perfect balance between fund and distributed yield", async function () {
    const initialFund = ethers.parseUnits("50000", 18);
    await crikz.connect(owner).fundProductionPool(initialFund);
    
    // Multiple users stake
    for (let i = 0; i < 5; i++) {
      await crikz.connect(users[i]).createOrder(ethers.parseUnits("1000", 18), i % 3);
    }
    
    // Time passes
    await time.increase(100 * 24 * 60 * 60);
    
    let totalClaimed = 0n;
    
    // All users claim
    for (let i = 0; i < 5; i++) {
      const balBefore = await crikz.balanceOf(users[i].address);
      await crikz.connect(users[i]).claimYield();
      const balAfter = await crikz.balanceOf(users[i].address);
      totalClaimed += (balAfter - balBefore);
    }
    
    // Verify fund balance
    const fundAfter = await crikz.productionFund();
    const expectedBalance = initialFund - totalClaimed;
    
    expect(fundAfter.balance).to.be.closeTo(expectedBalance, ethers.parseUnits("0.001", 18));
  });

  it("Should handle concurrent funding and claiming correctly", async function () {
    // Initial funding
    await crikz.connect(owner).fundProductionPool(ethers.parseUnits("10000", 18));
    
    // User stakes
    await crikz.connect(users[0]).createOrder(ethers.parseUnits("5000", 18), 0);
    
    // Time passes
    await time.increase(30 * 24 * 60 * 60);
    
    // Record state before operations
    const fundBefore = await crikz.productionFund();
    
    // Additional funding
    await crikz.connect(owner).fundProductionPool(ethers.parseUnits("5000", 18));
    
    // User claims
    await crikz.connect(users[0]).claimYield();
    
    // Verify fund state is consistent
    const fundAfter = await crikz.productionFund();
    expect(fundAfter.lastUpdateTime).to.be.gte(fundBefore.lastUpdateTime);
    expect(fundAfter.balance).to.be.gt(0);
  });

  it("Should prevent integer overflow in accumulated yield calculation", async function () {
    // Fund with maximum safe amount
    const hugeFund = ethers.parseUnits("100000000", 18); // 100M tokens
    await crikz.connect(owner).fundProductionPool(hugeFund);
    
    // Create order with large amount
    await crikz.connect(users[0]).createOrder(ethers.parseUnits("10000", 18), 0);
    
    // Wait maximum reasonable time (10 years)
    await time.increase(10 * 365 * 24 * 60 * 60);
    
    // Should not revert on claim
    await expect(crikz.connect(users[0]).claimYield()).to.not.be.reverted;
    
    // Verify fund didn't overflow
    const fund = await crikz.productionFund();
    expect(fund.accumulatedYieldPerReputation).to.be.gt(0);
  });

  it("Should handle fund depletion and refunding correctly", async function () {
    // Small initial fund
    await crikz.connect(owner).fundProductionPool(ethers.parseUnits("100", 18));
    
    // User stakes large amount
    await crikz.connect(users[0]).createOrder(ethers.parseUnits("10000", 18), 4);
    
    // Wait long time to deplete fund
    await time.increase(50 * 365 * 24 * 60 * 60);
    
    // Claim should deplete fund
    await crikz.connect(users[0]).claimYield();
    let fund = await crikz.productionFund();
    expect(fund.balance).to.be.lt(ethers.parseUnits("0.1", 18));
    
    // Refund
    await crikz.connect(owner).fundProductionPool(ethers.parseUnits("1000", 18));
    fund = await crikz.productionFund();
    expect(fund.balance).to.be.closeTo(ethers.parseUnits("1000", 18), ethers.parseUnits("0.1", 18));
    
    // Wait and claim again
    await time.increase(30 * 24 * 60 * 60);
    await expect(crikz.connect(users[0]).claimYield()).to.not.be.reverted;
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Crikz - ERC2771 Meta-Transaction Security", function () {
  let crikz, owner, trustedForwarder, user, attacker;

  beforeEach(async function () {
    [owner, trustedForwarder, user, attacker] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.connect(owner).deploy(trustedForwarder.address, owner.address);
    await crikz.waitForDeployment();
    
    await crikz.connect(owner).transfer(user.address, ethers.parseUnits("1000", 18));
    await crikz.connect(owner).transfer(attacker.address, ethers.parseUnits("1000", 18));
  });

  it("Should correctly extract sender from trusted forwarder calldata", async function () {
    const amount = ethers.parseUnits("100", 18);
    const orderType = 0;
    
    // Encode the function call
    const functionData = crikz.interface.encodeFunctionData("createOrder", [amount, orderType]);
    
    // Append user address (ERC2771 format)
    const dataWithSender = ethers.solidityPacked(
      ["bytes", "address"],
      [functionData, user.address]
    );
    
    // Send from trusted forwarder
    await trustedForwarder.sendTransaction({
      to: await crikz.getAddress(),
      data: dataWithSender
    });
    
    // Verify order was created for the correct user
    const orders = await crikz.getActiveOrders(user.address);
    expect(orders.length).to.equal(1);
    expect(orders[0].amount).to.equal(amount);
    
    // Verify forwarder doesn't have the order
    const forwarderOrders = await crikz.getActiveOrders(trustedForwarder.address);
    expect(forwarderOrders.length).to.equal(0);
  });

  it("Should reject spoofed sender from non-trusted forwarder", async function () {
    const amount = ethers.parseUnits("100", 18);
    const orderType = 0;
    
    // Attacker tries to spoof user's address
    const functionData = crikz.interface.encodeFunctionData("createOrder", [amount, orderType]);
    const spoofedData = ethers.solidityPacked(
      ["bytes", "address"],
      [functionData, user.address]
    );
    
    // Send from attacker (not trusted forwarder)
    await attacker.sendTransaction({
      to: await crikz.getAddress(),
      data: spoofedData
    });
    
    // Order should belong to attacker, not user
    const userOrders = await crikz.getActiveOrders(user.address);
    expect(userOrders.length).to.equal(0);
    
    const attackerOrders = await crikz.getActiveOrders(attacker.address);
    expect(attackerOrders.length).to.equal(1);
  });

  it("Should handle malformed calldata gracefully", async function () {
    // Send malformed data
    const malformedData = "0x1234567890";
    
    await expect(
      trustedForwarder.sendTransaction({
        to: await crikz.getAddress(),
        data: malformedData
      })
    ).to.be.reverted;
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Reentrancy Protection", function () {
  let crikz, owner, attacker;

  beforeEach(async function () {
    [owner, attacker] = await ethers.getSigners();
    
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.connect(owner).deploy(ethers.ZeroAddress, owner.address);
    await crikz.waitForDeployment();
    
    await crikz.connect(owner).transfer(attacker.address, ethers.parseUnits("10000", 18));
  });

  it("Should prevent reentrancy in claimYield", async function () {
    // Setup: Fund attacker and create order
    await crikz.connect(attacker).createOrder(ethers.parseUnits("500", 18), 0);
    await crikz.connect(owner).fundProductionPool(ethers.parseUnits("5000", 18));
    
    await time.increase(30 * 24 * 60 * 60);
    
    // First claim should succeed
    await crikz.connect(attacker).claimYield();
    
    // Immediate second claim should fail (no yield accumulated yet)
    await expect(crikz.connect(attacker).claimYield())
      .to.be.revertedWithCustomError(crikz, "NoProductsToClaim");
  });

  it("Should prevent reentrancy in completeOrder", async function () {
    await crikz.connect(attacker).createOrder(ethers.parseUnits("500", 18), 0);
    
    await time.increase(2 * 24 * 60 * 60);
    
    // Complete order
    await crikz.connect(attacker).completeOrder(0);
    
    // Try to complete same order again - should fail
    await expect(crikz.connect(attacker).completeOrder(0))
      .to.be.revertedWithCustomError(crikz, "InvalidOrderIndex");
  });

  it("Should prevent reentrancy in fundProductionPool", async function () {
    const amount = ethers.parseUnits("1000", 18);
    
    // Fund once
    await crikz.connect(owner).fundProductionPool(amount);
    
    // Verify ReentrancyGuard is in place by checking modifier exists
    // We can't directly test reentrancy without a malicious contract,
    // but we can verify the function completes correctly
    const fund = await crikz.productionFund();
    expect(fund.balance).to.equal(amount);
  });

  it("Should maintain state consistency after rapid successive calls", async function () {
    // Create multiple orders rapidly
    await crikz.connect(attacker).createOrder(ethers.parseUnits("100", 18), 0);
    await crikz.connect(attacker).createOrder(ethers.parseUnits("200", 18), 0);
    await crikz.connect(attacker).createOrder(ethers.parseUnits("300", 18), 0);
    
    const orders = await crikz.getActiveOrders(attacker.address);
    expect(orders.length).to.equal(3);
    
    // Fund pool
    await crikz.connect(owner).fundProductionPool(ethers.parseUnits("5000", 18));
    await time.increase(2 * 24 * 60 * 60);
    
    // Complete orders rapidly (tests reentrancy guard)
    await crikz.connect(attacker).completeOrder(0);
    await crikz.connect(attacker).completeOrder(0); // Index 0 again due to swap-and-pop
    await crikz.connect(attacker).completeOrder(0);
    
    // Verify all orders completed
    const remainingOrders = await crikz.getActiveOrders(attacker.address);
    expect(remainingOrders.length).to.equal(0);
  });

  it("Should handle multiple users claiming simultaneously without state corruption", async function () {
    const [, user1, user2, user3] = await ethers.getSigners();
    
    // Fund users
    await crikz.connect(owner).transfer(user1.address, ethers.parseUnits("1000", 18));
    await crikz.connect(owner).transfer(user2.address, ethers.parseUnits("1000", 18));
    await crikz.connect(owner).transfer(user3.address, ethers.parseUnits("1000", 18));
    
    // All create orders
    await crikz.connect(user1).createOrder(ethers.parseUnits("500", 18), 0);
    await crikz.connect(user2).createOrder(ethers.parseUnits("500", 18), 0);
    await crikz.connect(user3).createOrder(ethers.parseUnits("500", 18), 0);
    
    // Fund pool
    await crikz.connect(owner).fundProductionPool(ethers.parseUnits("10000", 18));
    await time.increase(30 * 24 * 60 * 60);
    
    // All claim (simulates concurrent transactions)
    await crikz.connect(user1).claimYield();
    await crikz.connect(user2).claimYield();
    await crikz.connect(user3).claimYield();
    
    // Verify fund integrity
    const fund = await crikz.productionFund();
    expect(fund.balance).to.be.gte(0);
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Gas Optimization & Scalability", function () {
  let crikz, owner, whale;

  beforeEach(async function () {
    [owner, whale] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.connect(owner).deploy(ethers.ZeroAddress, owner.address);
    await crikz.waitForDeployment();
    
    await crikz.connect(owner).transfer(whale.address, ethers.parseUnits("500000", 18));
  });

  it("Should handle 50 orders without exceeding reasonable gas limits", async function () {
    const orderCount = 50;
    
    // Create 50 orders
    for (let i = 0; i < orderCount; i++) {
      await crikz.connect(whale).createOrder(ethers.parseUnits("100", 18), i % 7);
    }
    
    // Fund pool
    await crikz.connect(owner).fundProductionPool(ethers.parseUnits("100000", 18));
    
    // Wait
    await time.increase(365 * 24 * 60 * 60);
    
    // Claim yield - should be O(1) operation
    const tx = await crikz.connect(whale).claimYield();
    const receipt = await tx.wait();
    
    console.log(`      [GAS] claimYield with 50 orders: ${receipt.gasUsed.toString()}`);
    
    // Should be under 500k gas (O(1) operation)
    expect(receipt.gasUsed).to.be.lt(500000n);
  });

  it("Should efficiently handle getActiveOrders for large arrays", async function () {
    // Create 100 orders
    for (let i = 0; i < 100; i++) {
      await crikz.connect(whale).createOrder(ethers.parseUnits("10", 18), i % 7);
    }
    
    // View call should not fail
    const orders = await crikz.getActiveOrders(whale.address);
    expect(orders.length).to.equal(100);
  });

  it("Should maintain reasonable gas for yield calculations regardless of fund size", async function () {
    // Test 1: Small fund
    await crikz.connect(owner).fundProductionPool(ethers.parseUnits("1000", 18));
    await crikz.connect(whale).createOrder(ethers.parseUnits("100", 18), 0);
    await time.increase(30 * 24 * 60 * 60);
    
    const tx1 = await crikz.connect(whale).claimYield();
    const receipt1 = await tx1.wait();
    const gas1 = receipt1.gasUsed;
    
    console.log(`      [GAS] Small fund claim: ${gas1.toString()}`);
    
    // Test 2: Large fund
    await crikz.connect(whale).createOrder(ethers.parseUnits("100", 18), 0);
    await crikz.connect(owner).fundProductionPool(ethers.parseUnits("1000000", 18));
    await time.increase(30 * 24 * 60 * 60);
    
    const tx2 = await crikz.connect(whale).claimYield();
    const receipt2 = await tx2.wait();
    const gas2 = receipt2.gasUsed;
    
    console.log(`      [GAS] Large fund claim: ${gas2.toString()}`);
    
    // Gas should be similar - both should be under 200k
    expect(gas1).to.be.lt(200000n);
    expect(gas2).to.be.lt(200000n);
    
    // Calculate percentage difference
    const gasDiff = gas2 > gas1 ? gas2 - gas1 : gas1 - gas2;
    const percentDiff = (gasDiff * 100n) / gas1;
    
    console.log(`      [GAS] Difference: ${percentDiff.toString()}%`);
    
    // Gas difference should be reasonable (within 50%)
    expect(percentDiff).to.be.lt(50n);
  });

  it("Should profile gas usage across common operations", async function () {
    const amount = ethers.parseUnits("1000", 18);
    
    // 1. Create Order
    const tx1 = await crikz.connect(whale).createOrder(amount, 2);
    const receipt1 = await tx1.wait();
    console.log(`      [GAS] createOrder: ${receipt1.gasUsed.toString()}`);
    expect(receipt1.gasUsed).to.be.lt(300000n);
    
    // 2. Fund Pool
    const tx2 = await crikz.connect(owner).fundProductionPool(ethers.parseUnits("10000", 18));
    const receipt2 = await tx2.wait();
    console.log(`      [GAS] fundPool: ${receipt2.gasUsed.toString()}`);
    expect(receipt2.gasUsed).to.be.lt(200000n);
    
    // 3. Claim Yield
    await time.increase(30 * 24 * 60 * 60);
    const tx3 = await crikz.connect(whale).claimYield();
    const receipt3 = await tx3.wait();
    console.log(`      [GAS] claimYield: ${receipt3.gasUsed.toString()}`);
    expect(receipt3.gasUsed).to.be.lt(200000n);
    
    // 4. Complete Order
    await time.increase(30 * 24 * 60 * 60);
    const tx4 = await crikz.connect(whale).completeOrder(0);
    const receipt4 = await tx4.wait();
    console.log(`      [GAS] completeOrder: ${receipt4.gasUsed.toString()}`);
    expect(receipt4.gasUsed).to.be.lt(200000n);
  });
});

const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Crikz - Yield Mathematics Edge Cases", function () {
  let crikz, owner, user;

  beforeEach(async function () {
    [owner, user] = await ethers.getSigners();
    const Crikz = await ethers.getContractFactory("Crikz");
    crikz = await Crikz.connect(owner).deploy(ethers.ZeroAddress, owner.address);
    await crikz.waitForDeployment();
    
    await crikz.connect(owner).transfer(user.address, ethers.parseUnits("10000", 18));
  });

  it("Should handle 1 second time intervals correctly", async function () {
    await crikz.connect(user).createOrder(ethers.parseUnits("1000", 18), 0);
    await crikz.connect(owner).fundProductionPool(ethers.parseUnits("10000", 18));
    
    // Wait exactly 1 second
    await time.increase(1);
    
    // Should be able to claim tiny amount without reverting
    await expect(crikz.connect(user).claimYield()).to.not.be.reverted;
  });

  it("Should correctly calculate yield for sub-day time periods", async function () {
    await crikz.connect(user).createOrder(ethers.parseUnits("1000", 18), 0);
    await crikz.connect(owner).fundProductionPool(ethers.parseUnits("100000", 18));
    
    // Wait 6 hours
    await time.increase(6 * 60 * 60);
    
    const balBefore = await crikz.balanceOf(user.address);
    await crikz.connect(user).claimYield();
    const balAfter = await crikz.balanceOf(user.address);
    
    const yield1 = balAfter - balBefore;
    expect(yield1).to.be.gt(0);
    
    // Wait another 6 hours
    await time.increase(6 * 60 * 60);
    
    const balBefore2 = await crikz.balanceOf(user.address);
    await crikz.connect(user).claimYield();
    const balAfter2 = await crikz.balanceOf(user.address);
    
    const yield2 = balAfter2 - balBefore2;
    
    // Yields should be approximately equal
    expect(yield2).to.be.closeTo(yield1, ethers.parseUnits("0.1", 18));
  });

  it("Should handle maximum timestamp (year 2106) without overflow", async function () {
    await crikz.connect(user).createOrder(ethers.parseUnits("1000", 18), 0);
    await crikz.connect(owner).fundProductionPool(ethers.parseUnits("10000", 18));
    
    // Jump to near maximum uint256 timestamp (year 2106)
    // Note: This might not work in practice, but tests the math
    const maxReasonableTime = 50 * 365 * 24 * 60 * 60; // 50 years
    await time.increase(maxReasonableTime);
    
    // Should not overflow
    await expect(crikz.connect(user).claimYield()).to.not.be.reverted;
  });

  it("Should maintain precision with very small reputation values", async function () {
    // Create order with minimum amount that gives reputation > 0
    const minAmount = ethers.parseUnits("2", 18); // 2 tokens gives 1.236 reputation
    await crikz.connect(user).createOrder(minAmount, 0);
    await crikz.connect(owner).fundProductionPool(ethers.parseUnits("1000000", 18));
    
    await time.increase(365 * 24 * 60 * 60);
    
    // Should accumulate some yield
    await expect(crikz.connect(user).claimYield()).to.not.be.reverted;
  });
});